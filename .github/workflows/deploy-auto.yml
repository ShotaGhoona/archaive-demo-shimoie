name: Deploy (Auto)

# è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ•ãƒ­ãƒ¼
# - developãƒ–ãƒ©ãƒ³ãƒ â†’ Stagingç’°å¢ƒ
# - mainãƒ–ãƒ©ãƒ³ãƒ â†’ Productionç’°å¢ƒ
#
# ãƒ‡ãƒ—ãƒ­ã‚¤é †åº:
# 1. å·®åˆ†æ¤œå‡º (detect-changes)
# 2. ã‚¤ãƒ³ãƒ•ãƒ©ãƒ‡ãƒ—ãƒ­ã‚¤ (CDK)
# 3. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤ (ECS)
# 4. DBãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (Alembic)

on:
  push:
    branches:
      - develop  # Stagingç’°å¢ƒã¸è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤
      - main     # Productionç’°å¢ƒã¸è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤
    paths:
      - 'infra/**'
      - 'backend/**'
      - '.github/workflows/deploy-auto.yml'

  workflow_dispatch:  # æ‰‹å‹•å®Ÿè¡Œã‚‚å¯èƒ½
    inputs:
      environment:
        description: 'ãƒ‡ãƒ—ãƒ­ã‚¤å…ˆç’°å¢ƒ'
        required: true
        type: choice
        options:
          - stg
          - prod
      deploy_target:
        description: 'ãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - infra-only
          - backend-only
      stack:
        description: 'ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ã‚¿ãƒƒã‚¯ (all/foundation/data/security/backend/frontend/integration/observability)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - foundation
          - data
          - security
          - backend
          - frontend
          - integration
          - observability

# åŒæ™‚å®Ÿè¡Œåˆ¶å¾¡: åŒã˜ç’°å¢ƒã¸ã®åŒæ™‚ãƒ‡ãƒ—ãƒ­ã‚¤ã‚’é˜²æ­¢
concurrency:
  group: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}-deployment
  cancel-in-progress: false

env:
  AWS_REGION: ap-northeast-1
  NODE_VERSION_INFRA: '18'
  PYTHON_VERSION: '3.11'

jobs:
  # ========================================
  # Job 0: å¤‰æ›´æ¤œå‡º
  # ========================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    # pushã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã®ã¿å®Ÿè¡Œï¼ˆæ‰‹å‹•å®Ÿè¡Œæ™‚ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
    if: github.event_name == 'push'
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      backend: ${{ steps.filter.outputs.backend }}
      env_name: ${{ steps.set-env.outputs.env_name }}
      env_display: ${{ steps.set-env.outputs.env_display }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        id: set-env
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV_NAME="prod"
          else
            ENV_NAME="stg"
          fi
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          ENV_DISPLAY=$(echo "${ENV_NAME}" | tr '[:lower:]' '[:upper:]')
          echo "env_display=${ENV_DISPLAY}" >> $GITHUB_OUTPUT

      - name: Check changed files
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
              - 'infra/**'
              - '.github/workflows/deploy-auto.yml'
            backend:
              - 'backend/**'
              - '.github/workflows/deploy-auto.yml'

  # ========================================
  # Job 1: ã‚¤ãƒ³ãƒ•ãƒ©ãƒ‡ãƒ—ãƒ­ã‚¤ (CDK)
  # ========================================
  deploy-infra:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã®æ¡ä»¶ã§å®Ÿè¡Œ:
    # - pushã‚¤ãƒ™ãƒ³ãƒˆ ã‹ã¤ infra/** ã«å¤‰æ›´ãŒã‚ã‚‹
    # - æ‰‹å‹•å®Ÿè¡Œ ã‹ã¤ backend-only ä»¥å¤–ãŒé¸æŠžã•ã‚ŒãŸ
    if: |
      always() &&
      (
        (github.event_name == 'push' && needs.detect-changes.outputs.infra == 'true') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_target != 'backend-only')
      )

    permissions:
      id-token: write
      contents: read

    outputs:
      infra_deployed: ${{ steps.deploy-result.outputs.deployed }}
      env_name: ${{ steps.set-env.outputs.env_name }}

    steps:
      - name: Set environment variables
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          else
            ENV_NAME="${{ needs.detect-changes.outputs.env_name }}"
          fi
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          ENV_DISPLAY=$(echo "${ENV_NAME}" | tr '[:lower:]' '[:upper:]')
          echo "env_display=${ENV_DISPLAY}" >> $GITHUB_OUTPUT

      - name: ðŸ—ï¸ Infrastructure Deployment Started
        run: |
          echo "================================================"
          echo "ðŸ—ï¸  ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã‚’${{ steps.set-env.outputs.env_display }}ç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™"
          echo "================================================"
          echo "Environment: ${{ steps.set-env.outputs.env_display }}"
          echo "Stack: ${{ github.event.inputs.stack || 'all' }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "================================================"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION_INFRA }}
          cache: 'npm'
          cache-dependency-path: infra/package-lock.json

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.set-env.outputs.env_name == 'prod' && secrets.AWS_ROLE_ARN_PROD || secrets.AWS_ROLE_ARN_STG }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install dependencies
        working-directory: infra
        run: npm ci

      - name: Build CDK
        working-directory: infra
        run: npm run build

      - name: Run tests
        working-directory: infra
        run: npm test
        continue-on-error: true

      - name: CDK Diff
        working-directory: infra
        run: npx cdk diff --all --context env=${{ steps.set-env.outputs.env_name }}
        continue-on-error: true

      - name: Determine stacks to deploy
        id: determine-stacks
        run: |
          STACK_INPUT="${{ github.event.inputs.stack || 'all' }}"
          ENV="${{ steps.set-env.outputs.env_name }}"

          case $STACK_INPUT in
            all)
              STACKS="--all"
              ;;
            foundation)
              STACKS="${ENV}-FoundationStack"
              ;;
            data)
              STACKS="${ENV}-DataStack"
              ;;
            security)
              STACKS="${ENV}-SecurityStack"
              ;;
            backend)
              STACKS="${ENV}-BackendStack"
              ;;
            frontend)
              STACKS="${ENV}-FrontendStack"
              ;;
            integration)
              STACKS="${ENV}-IntegrationStack"
              ;;
            observability)
              STACKS="${ENV}-ObservabilityStack"
              ;;
            *)
              echo "Invalid stack selection"
              exit 1
              ;;
          esac

          echo "stacks=$STACKS" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Deploying stacks: $STACKS"

      - name: CDK Deploy
        id: deploy-result
        working-directory: infra
        run: |
          echo "ðŸš€ Deploying: ${{ steps.determine-stacks.outputs.stacks }}"

          npx cdk deploy ${{ steps.determine-stacks.outputs.stacks }} \
            --require-approval never \
            --context env=${{ steps.set-env.outputs.env_name }} \
            --outputs-file ./cdk-outputs-${{ steps.set-env.outputs.env_name }}.json

          echo "deployed=true" >> $GITHUB_OUTPUT

      - name: Upload CDK outputs
        uses: actions/upload-artifact@v4
        with:
          name: cdk-outputs-${{ steps.set-env.outputs.env_name }}-${{ github.sha }}
          path: infra/cdk-outputs-${{ steps.set-env.outputs.env_name }}.json
          retention-days: ${{ steps.set-env.outputs.env_name == 'prod' && 365 || 90 }}

      - name: Create deployment summary
        if: success()
        run: |
          echo "## ðŸŽ‰ Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ steps.set-env.outputs.env_display }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Stacks:** ${{ steps.determine-stacks.outputs.stacks }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY

  # ========================================
  # Job 2: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤ (ECS)
  # ========================================
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-infra]
    # ã‚¤ãƒ³ãƒ•ãƒ©ãŒæˆåŠŸ/ã‚¹ã‚­ãƒƒãƒ— ã‹ã¤ (backendå¤‰æ›´ã‚ã‚Š ã¾ãŸã¯ ã‚¤ãƒ³ãƒ•ãƒ©ãŒãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚ŒãŸ)
    if: |
      always() &&
      (needs.deploy-infra.result == 'success' || needs.deploy-infra.result == 'skipped') &&
      (
        (github.event_name == 'push' && (needs.detect-changes.outputs.backend == 'true' || needs.deploy-infra.outputs.infra_deployed == 'true')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_target != 'infra-only')
      )

    permissions:
      id-token: write
      contents: read

    outputs:
      backend_deployed: ${{ steps.deploy-result.outputs.deployed }}

    steps:
      - name: Set environment variables
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          else
            ENV_NAME="${{ needs.detect-changes.outputs.env_name }}"
          fi
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          ENV_DISPLAY=$(echo "${ENV_NAME}" | tr '[:lower:]' '[:upper:]')
          echo "env_display=${ENV_DISPLAY}" >> $GITHUB_OUTPUT

      - name: ðŸš€ Backend Deployment Started
        run: |
          echo "================================================"
          echo "ðŸ“¦ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’${{ steps.set-env.outputs.env_display }}ç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™"
          echo "================================================"
          echo "Environment: ${{ steps.set-env.outputs.env_display }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "================================================"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.set-env.outputs.env_name == 'prod' && secrets.AWS_ROLE_ARN_PROD || secrets.AWS_ROLE_ARN_STG }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECS cluster and service names
        id: get-ecs-info
        run: |
          # CloudFormation outputsã‹ã‚‰å–å¾—
          CLUSTER_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ steps.set-env.outputs.env_name }}-BackendStack \
            --query 'Stacks[0].Outputs[?OutputKey==`EcsClusterName`].OutputValue' \
            --output text)

          SERVICE_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ steps.set-env.outputs.env_name }}-BackendStack \
            --query 'Stacks[0].Outputs[?OutputKey==`EcsServiceName`].OutputValue' \
            --output text)

          ECR_REPO=$(aws cloudformation describe-stacks \
            --stack-name ${{ steps.set-env.outputs.env_name }}-BackendStack \
            --query 'Stacks[0].Outputs[?OutputKey==`BackendEcrRepositoryUri`].OutputValue' \
            --output text)

          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "ecr_repository=$ECR_REPO" >> $GITHUB_OUTPUT

      - name: Build, tag, and push Docker image
        id: build-image
        working-directory: backend
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ECR_REPO="${{ steps.get-ecs-info.outputs.ecr_repository }}"

          echo "ðŸ³ Building Docker image..."
          docker build -t $ECR_REPO:$IMAGE_TAG .

          echo "ðŸ“¤ Pushing image to ECR..."
          # ã‚³ãƒŸãƒƒãƒˆSHAã‚¿ã‚°ï¼ˆãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£ç”¨ï¼‰
          docker push $ECR_REPO:$IMAGE_TAG

          # latestã‚¿ã‚°ï¼ˆECSã‚¿ã‚¹ã‚¯å®šç¾©ç”¨ï¼‰
          docker tag $ECR_REPO:$IMAGE_TAG $ECR_REPO:latest
          docker push $ECR_REPO:latest

          echo "image=$ECR_REPO:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "âœ… Image pushed: $ECR_REPO:$IMAGE_TAG and $ECR_REPO:latest"

      - name: Update ECS Service
        id: deploy-result
        run: |
          echo "ðŸš€ Deploying to ECS..."
          aws ecs update-service \
            --cluster ${{ steps.get-ecs-info.outputs.cluster_name }} \
            --service ${{ steps.get-ecs-info.outputs.service_name }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          echo "deployed=true" >> $GITHUB_OUTPUT
          echo "âœ… ECS service update initiated"

      - name: Wait for ECS deployment
        run: |
          echo "â³ Waiting for ECS service to stabilize (max 10 minutes)..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ steps.get-ecs-info.outputs.cluster_name }} \
            --services ${{ steps.get-ecs-info.outputs.service_name }} \
            --region ${{ env.AWS_REGION }} || {
              echo "âŒ Deployment timeout or failed"
              exit 1
            }
          echo "âœ… ECS service is stable"

      - name: Get ALB DNS for health check
        id: get-alb
        run: |
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name ${{ steps.set-env.outputs.env_name }}-BackendStack \
            --query 'Stacks[0].Outputs[?OutputKey==`AlbDnsName`].OutputValue' \
            --output text)
          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT

      - name: Health Check
        run: |
          echo "ðŸ¥ Running health check..."
          ALB_DNS="${{ steps.get-alb.outputs.alb_dns }}"

          for i in {1..30}; do
            echo "Attempt $i/30: Checking http://$ALB_DNS/health"

            if curl -f -s -o /dev/null -w "%{http_code}" http://$ALB_DNS/health | grep -q "200"; then
              echo "âœ… Health check passed!"
              exit 0
            fi

            echo "â³ Waiting 10 seconds before retry..."
            sleep 10
          done

          echo "âŒ Health check failed after 30 attempts"
          exit 1

      - name: Create deployment summary
        if: success()
        run: |
          echo "## ðŸŽ‰ Backend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ steps.set-env.outputs.env_display }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Image:** ${{ steps.build-image.outputs.image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Cluster:** ${{ steps.get-ecs-info.outputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Service:** ${{ steps.get-ecs-info.outputs.service_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ALB:** http://${{ steps.get-alb.outputs.alb_dns }}" >> $GITHUB_STEP_SUMMARY

  # ========================================
  # Job 3: DBãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (ECSã‚¿ã‚¹ã‚¯ã§å®Ÿè¡Œ)
  # ========================================
  migrate-database:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-infra, deploy-backend]
    # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãŒæˆåŠŸã—ãŸå ´åˆã®ã¿å®Ÿè¡Œï¼ˆæ–°ã—ã„ã‚¤ãƒ¡ãƒ¼ã‚¸ãŒå¿…è¦ï¼‰
    if: |
      always() &&
      needs.deploy-backend.result == 'success'

    permissions:
      id-token: write
      contents: read

    outputs:
      migration_executed: ${{ steps.migration-result.outputs.executed }}

    steps:
      - name: Set environment variables
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          else
            ENV_NAME="${{ needs.detect-changes.outputs.env_name }}"
          fi
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          ENV_DISPLAY=$(echo "${ENV_NAME}" | tr '[:lower:]' '[:upper:]')
          echo "env_display=${ENV_DISPLAY}" >> $GITHUB_OUTPUT

      - name: ðŸ—„ï¸ Database Migration Started
        run: |
          echo "================================================"
          echo "ðŸ—„ï¸  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ECSã‚¿ã‚¹ã‚¯ã§å®Ÿè¡Œã—ã¾ã™"
          echo "================================================"
          echo "Environment: ${{ steps.set-env.outputs.env_display }}"
          echo "================================================"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.set-env.outputs.env_name == 'prod' && secrets.AWS_ROLE_ARN_PROD || secrets.AWS_ROLE_ARN_STG }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECS info for migration
        id: get-ecs-info
        run: |
          ENV_NAME="${{ steps.set-env.outputs.env_name }}"

          # ECSã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼åã‚’å–å¾—
          CLUSTER_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${ENV_NAME}-BackendStack \
            --query 'Stacks[0].Outputs[?OutputKey==`EcsClusterName`].OutputValue' \
            --output text)

          # ECSã‚µãƒ¼ãƒ“ã‚¹åã‚’å–å¾—
          SERVICE_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${ENV_NAME}-BackendStack \
            --query 'Stacks[0].Outputs[?OutputKey==`EcsServiceName`].OutputValue' \
            --output text)

          # ã‚µãƒ¼ãƒ“ã‚¹ã‹ã‚‰ã‚¿ã‚¹ã‚¯å®šç¾©ã‚’å–å¾—
          TASK_DEFINITION=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].taskDefinition' \
            --output text)

          # ã‚µãƒ–ãƒãƒƒãƒˆã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å–å¾—ï¼ˆã‚µãƒ¼ãƒ“ã‚¹ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®šã‹ã‚‰ï¼‰
          NETWORK_CONFIG=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].networkConfiguration.awsvpcConfiguration' \
            --output json)

          SUBNETS=$(echo $NETWORK_CONFIG | jq -r '.subnets | join(",")')
          SECURITY_GROUPS=$(echo $NETWORK_CONFIG | jq -r '.securityGroups | join(",")')

          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "task_definition=$TASK_DEFINITION" >> $GITHUB_OUTPUT
          echo "subnets=$SUBNETS" >> $GITHUB_OUTPUT
          echo "security_groups=$SECURITY_GROUPS" >> $GITHUB_OUTPUT

          echo "ðŸ“¦ Cluster: $CLUSTER_NAME"
          echo "ðŸ“‹ Task Definition: $TASK_DEFINITION"

      - name: Run migration task
        id: run-migration
        run: |
          echo "ðŸš€ Starting migration task..."

          # ECSã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆã‚³ãƒžãƒ³ãƒ‰ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦alembic upgrade headã‚’å®Ÿè¡Œï¼‰
          # ã‚³ãƒ³ãƒ†ãƒŠåã¯ api-resource.ts ã§å®šç¾©ã•ã‚ŒãŸ "app"
          TASK_ARN=$(aws ecs run-task \
            --cluster ${{ steps.get-ecs-info.outputs.cluster_name }} \
            --task-definition ${{ steps.get-ecs-info.outputs.task_definition }} \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.get-ecs-info.outputs.subnets }}],securityGroups=[${{ steps.get-ecs-info.outputs.security_groups }}],assignPublicIp=DISABLED}" \
            --overrides '{
              "containerOverrides": [{
                "name": "app",
                "command": ["alembic", "upgrade", "head"]
              }]
            }' \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Migration task started: $TASK_ARN"

      - name: Wait for migration task to complete
        id: wait-migration
        run: |
          TASK_ARN="${{ steps.run-migration.outputs.task_arn }}"
          CLUSTER="${{ steps.get-ecs-info.outputs.cluster_name }}"

          echo "â³ Waiting for migration task to complete..."

          # ã‚¿ã‚¹ã‚¯å®Œäº†ã‚’å¾…æ©Ÿï¼ˆæœ€å¤§10åˆ†ï¼‰
          aws ecs wait tasks-stopped \
            --cluster $CLUSTER \
            --tasks $TASK_ARN

          # çµ‚äº†ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèª
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster $CLUSTER \
            --tasks $TASK_ARN \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)

          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

          if [ "$EXIT_CODE" = "0" ]; then
            echo "âœ… Migration completed successfully"
          else
            echo "âŒ Migration failed with exit code: $EXIT_CODE"

            # CloudWatch Logsã‹ã‚‰ãƒ­ã‚°ã‚’å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
            TASK_ID=$(echo $TASK_ARN | awk -F'/' '{print $NF}')
            echo "ðŸ“‹ Task ID: $TASK_ID"
            echo "Check CloudWatch Logs for details"

            exit 1
          fi

      - name: Migration result
        id: migration-result
        run: |
          echo "executed=true" >> $GITHUB_OUTPUT

      - name: Create migration summary
        if: success()
        run: |
          echo "## ðŸ—„ï¸ Database Migration Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ steps.set-env.outputs.env_display }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Task ARN:** ${{ steps.run-migration.outputs.task_arn }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Exit Code:** ${{ steps.wait-migration.outputs.exit_code }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY

  # ========================================
  # æœ€çµ‚ã‚µãƒžãƒªãƒ¼
  # ========================================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-infra, deploy-backend, migrate-database]
    if: always()

    steps:
      - name: Create final summary
        run: |
          echo "## ðŸŽ‰ Deployment Pipeline Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Results:" >> $GITHUB_STEP_SUMMARY
          echo "- **Infrastructure:** ${{ needs.deploy-infra.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend:** ${{ needs.deploy-backend.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Database Migration:** ${{ needs.migrate-database.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
